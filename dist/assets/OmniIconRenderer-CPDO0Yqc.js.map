{"version":3,"mappings":"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","names":["requestQueue: QueueItem[]","queueItem!: QueueItem","entry: InflightEntry","consumer: ConsumerEntry","data: IconApiResponse"],"ignoreList":[0],"sources":["../../node_modules/.pnpm/idb-keyval@6.2.2/node_modules/idb-keyval/dist/index.js","../../resources/webcomponents/IconRegistry.ts","../../resources/webcomponents/OmniIconRenderer.ts"],"sourcesContent":["function promisifyRequest(request) {\n    return new Promise((resolve, reject) => {\n        // @ts-ignore - file size hacks\n        request.oncomplete = request.onsuccess = () => resolve(request.result);\n        // @ts-ignore - file size hacks\n        request.onabort = request.onerror = () => reject(request.error);\n    });\n}\nfunction createStore(dbName, storeName) {\n    let dbp;\n    const getDB = () => {\n        if (dbp)\n            return dbp;\n        const request = indexedDB.open(dbName);\n        request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n        dbp = promisifyRequest(request);\n        dbp.then((db) => {\n            // It seems like Safari sometimes likes to just close the connection.\n            // It's supposed to fire this event when that happens. Let's hope it does!\n            db.onclose = () => (dbp = undefined);\n        }, () => { });\n        return dbp;\n    };\n    return (txMode, callback) => getDB().then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));\n}\nlet defaultGetStoreFunc;\nfunction defaultGetStore() {\n    if (!defaultGetStoreFunc) {\n        defaultGetStoreFunc = createStore('keyval-store', 'keyval');\n    }\n    return defaultGetStoreFunc;\n}\n/**\n * Get a value by its key.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction get(key, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => promisifyRequest(store.get(key)));\n}\n/**\n * Set a value with a key.\n *\n * @param key\n * @param value\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction set(key, value, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.put(value, key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Set multiple values at once. This is faster than calling set() multiple times.\n * It's also atomic â€“ if one of the pairs can't be added, none will be added.\n *\n * @param entries Array of entries, where each entry is an array of `[key, value]`.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction setMany(entries, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        entries.forEach((entry) => store.put(entry[1], entry[0]));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Get multiple values by their keys\n *\n * @param keys\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction getMany(keys, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => Promise.all(keys.map((key) => promisifyRequest(store.get(key)))));\n}\n/**\n * Update a value. This lets you see the old value and update it as an atomic operation.\n *\n * @param key\n * @param updater A callback that takes the old value and returns a new value.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction update(key, updater, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => \n    // Need to create the promise manually.\n    // If I try to chain promises, the transaction closes in browsers\n    // that use a promise polyfill (IE10/11).\n    new Promise((resolve, reject) => {\n        store.get(key).onsuccess = function () {\n            try {\n                store.put(updater(this.result), key);\n                resolve(promisifyRequest(store.transaction));\n            }\n            catch (err) {\n                reject(err);\n            }\n        };\n    }));\n}\n/**\n * Delete a particular key from the store.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction del(key, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.delete(key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Delete multiple keys at once.\n *\n * @param keys List of keys to delete.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction delMany(keys, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        keys.forEach((key) => store.delete(key));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Clear all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction clear(customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.clear();\n        return promisifyRequest(store.transaction);\n    });\n}\nfunction eachCursor(store, callback) {\n    store.openCursor().onsuccess = function () {\n        if (!this.result)\n            return;\n        callback(this.result);\n        this.result.continue();\n    };\n    return promisifyRequest(store.transaction);\n}\n/**\n * Get all keys in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction keys(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAllKeys) {\n            return promisifyRequest(store.getAllKeys());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);\n    });\n}\n/**\n * Get all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction values(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAll) {\n            return promisifyRequest(store.getAll());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.value)).then(() => items);\n    });\n}\n/**\n * Get all entries in the store. Each entry is an array of `[key, value]`.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction entries(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        // (although, hopefully we'll get a simpler path some day)\n        if (store.getAll && store.getAllKeys) {\n            return Promise.all([\n                promisifyRequest(store.getAllKeys()),\n                promisifyRequest(store.getAll()),\n            ]).then(([keys, values]) => keys.map((key, i) => [key, values[i]]));\n        }\n        const items = [];\n        return customStore('readonly', (store) => eachCursor(store, (cursor) => items.push([cursor.key, cursor.value])).then(() => items));\n    });\n}\n\nexport { clear, createStore, del, delMany, entries, get, getMany, keys, promisifyRequest, set, setMany, update, values };\n","// Import only what we need for lighter bundle\nimport { get as getIdb, set as setIdb } from 'idb-keyval';\n\nexport interface IconApiResponse {\n\tsvg: string;\n\tprefix?: string;\n\tname?: string;\n}\n\nexport enum IconErrorType {\n\tNO_NAME = 'NO_NAME',\n\tNAME_NOT_FOUND = 'NAME_NOT_FOUND',\n\tINVALID_FORMAT = 'INVALID_FORMAT',\n\tFETCH_FAILED = 'FETCH_FAILED',\n\tINVALID_RESPONSE = 'INVALID_RESPONSE',\n}\n\nexport class IconError extends Error {\n\tconstructor(\n\t\tpublic type: IconErrorType,\n\t\tmessage: string,\n\t\tpublic originalError?: Error\n\t) {\n\t\tsuper(message);\n\t}\n}\n\ninterface ConsumerEntry {\n\tsignal: AbortSignal | null;\n\thandler?: () => void;\n}\n\ninterface QueueItem {\n\ticonName: string;\n\tprefix: string;\n\tname: string;\n\tpriority: number;\n\tresolve: (svg: string) => void;\n\treject: (error: Error) => void;\n\tabortController: AbortController;\n\tcleanup: () => void;\n\tstarted: boolean;\n}\n\ninterface InflightEntry {\n\ticonName: string;\n\tpromise: Promise<string>;\n\tabortController: AbortController;\n\tconsumers: Set<ConsumerEntry>;\n\tqueueItem: QueueItem;\n}\n\nexport interface IconRegistryStats {\n\tmemorySize: number;\n\tinflightCount: number;\n\tqueueSize: number;\n}\n\nexport interface IconFetchOptions {\n\tsignal?: AbortSignal;\n\tpriority?: number;\n}\n\nconst API_BASE_PATH = '/wp-json/omni-icon/v1/icon/item';\nconst IDB_KEY = 'oiwc-cache';\nconst MAX_CONCURRENT_REQUESTS = 4;\n\nconst iconCache = new Map<string, string>();\nconst inflightRequests = new Map<string, InflightEntry>();\nconst requestQueue: QueueItem[] = [];\nlet activeRequests = 0;\n\nexport async function fetchIcon(\n\ticonName: string,\n\tprefix: string,\n\tname: string,\n\toptions?: IconFetchOptions\n): Promise<string> {\n\tconst { signal, priority = 0 } = options ?? {};\n\n\tconst cached = iconCache.get(iconName);\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tconst stored = await readFromIndexedDb(iconName);\n\tif (stored) {\n\t\ticonCache.set(iconName, stored);\n\t\treturn stored;\n\t}\n\n\tconst entry = ensureInflightEntry(iconName, prefix, name, priority);\n\tattachConsumer(entry, signal);\n\treturn entry.promise;\n}\n\nfunction ensureInflightEntry(iconName: string, prefix: string, name: string, priority: number): InflightEntry {\n\tlet entry = inflightRequests.get(iconName);\n\tif (!entry) {\n\t\tentry = createInflightEntry(iconName, prefix, name, priority);\n\t\tinflightRequests.set(iconName, entry);\n\t} else if (!entry.queueItem.started && priority > entry.queueItem.priority) {\n\t\tentry.queueItem.priority = priority;\n\t\tsortQueue();\n\t}\n\n\treturn entry;\n}\n\nfunction createInflightEntry(iconName: string, prefix: string, name: string, priority: number): InflightEntry {\n\tconst abortController = new AbortController();\n\tconst consumers = new Set<ConsumerEntry>();\n\tlet queueItem!: QueueItem;\n\n\tconst entry: InflightEntry = {\n\t\ticonName,\n\t\tabortController,\n\t\tconsumers,\n\t\tqueueItem: {} as QueueItem,\n\t\tpromise: Promise.resolve(''),\n\t};\n\n\tconst basePromise = new Promise<string>((resolve, reject) => {\n\t\tqueueItem = {\n\t\t\ticonName,\n\t\t\tprefix,\n\t\t\tname,\n\t\t\tpriority,\n\t\t\tresolve,\n\t\t\treject,\n\t\t\tabortController,\n\t\t\tcleanup: () => detachAllConsumers(entry),\n\t\t\tstarted: false,\n\t\t};\n\n\t\tentry.queueItem = queueItem;\n\t\tinsertIntoQueue(queueItem);\n\t\tprocessQueue();\n\t});\n\n\tentry.promise = basePromise\n\t\t.then((svg) => {\n\t\t\ticonCache.set(iconName, svg);\n\t\t\tsaveToIndexedDb(iconName, svg);\n\t\t\treturn svg;\n\t\t})\n\t\t.finally(() => {\n\t\t\tdetachAllConsumers(entry);\n\t\t\tinflightRequests.delete(iconName);\n\t\t});\n\n\treturn entry;\n}\n\nfunction attachConsumer(entry: InflightEntry, signal?: AbortSignal): void {\n\tconst consumer: ConsumerEntry = {\n\t\tsignal: signal ?? null,\n\t};\n\n\tentry.consumers.add(consumer);\n\n\tif (signal) {\n\t\tconst handler = () => handleConsumerAbort(entry, consumer);\n\t\tconsumer.handler = handler;\n\t\tsignal.addEventListener('abort', handler);\n\t\tif (signal.aborted) {\n\t\t\thandler();\n\t\t}\n\t}\n}\n\nfunction handleConsumerAbort(entry: InflightEntry, consumer: ConsumerEntry): void {\n\tif (!entry.consumers.has(consumer)) {\n\t\treturn;\n\t}\n\n\tif (consumer.signal && consumer.handler) {\n\t\tconsumer.signal.removeEventListener('abort', consumer.handler);\n\t}\n\n\tentry.consumers.delete(consumer);\n\n\tif (entry.consumers.size > 0) {\n\t\treturn;\n\t}\n\n\tif (!entry.queueItem.started) {\n\t\tremoveFromQueue(entry.queueItem);\n\t\tentry.queueItem.cleanup();\n\t\tentry.queueItem.reject(\n\t\t\tnew IconError(\n\t\t\t\tIconErrorType.FETCH_FAILED,\n\t\t\t\t`Icon request aborted before start for \"${entry.iconName}\"`\n\t\t\t)\n\t\t);\n\t\treturn;\n\t}\n\n\tentry.abortController.abort();\n}\n\nfunction detachAllConsumers(entry: InflightEntry): void {\n\tentry.consumers.forEach((consumer) => {\n\t\tif (consumer.signal && consumer.handler) {\n\t\t\tconsumer.signal.removeEventListener('abort', consumer.handler);\n\t\t}\n\t});\n\tentry.consumers.clear();\n}\n\nfunction insertIntoQueue(item: QueueItem): void {\n\trequestQueue.push(item);\n\tsortQueue();\n}\n\nfunction sortQueue(): void {\n\trequestQueue.sort((a, b) => b.priority - a.priority);\n}\n\nfunction removeFromQueue(item: QueueItem): void {\n\tconst index = requestQueue.indexOf(item);\n\tif (index !== -1) {\n\t\trequestQueue.splice(index, 1);\n\t}\n}\n\nfunction processQueue(): void {\n\twhile (activeRequests < MAX_CONCURRENT_REQUESTS && requestQueue.length > 0) {\n\t\tconst item = requestQueue.shift();\n\t\tif (!item) {\n\t\t\tbreak;\n\t\t}\n\n\t\titem.started = true;\n\t\tactiveRequests++;\n\n\t\tprocessQueueItem(item)\n\t\t\t.finally(() => {\n\t\t\t\t// Decrement first to update the queue state before cleanup\n\t\t\t\tactiveRequests--;\n\t\t\t\t// Cleanup consumers after decrementing to avoid triggering new requests mid-cleanup\n\t\t\t\titem.cleanup();\n\t\t\t\t// Process next items in queue\n\t\t\t\tprocessQueue();\n\t\t\t});\n\t}\n}\n\nasync function processQueueItem(item: QueueItem): Promise<void> {\n\ttry {\n\t\tconst svg = await performFetch(item.iconName, item.prefix, item.name, item.abortController);\n\t\titem.resolve(svg);\n\t} catch (error) {\n\t\tif (error instanceof DOMException && error.name === 'AbortError') {\n\t\t\titem.reject(\n\t\t\t\tnew IconError(\n\t\t\t\t\tIconErrorType.FETCH_FAILED,\n\t\t\t\t\t`Icon request aborted for \"${item.iconName}\"`\n\t\t\t\t)\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\titem.reject(error instanceof Error ? error : new Error('Unknown error'));\n\t}\n}\n\nasync function readFromIndexedDb(iconName: string): Promise<string | undefined> {\n\ttry {\n\t\tconst stored = await getIdb(`${IDB_KEY}.${iconName}`);\n\t\treturn typeof stored === 'string' ? stored : undefined;\n\t} catch {\n\t\t// Silent fail - fallback to network fetch\n\t\treturn undefined;\n\t}\n}\n\nasync function saveToIndexedDb(iconName: string, svg: string): Promise<void> {\n\ttry {\n\t\tawait setIdb(`${IDB_KEY}.${iconName}`, svg);\n\t} catch {\n\t\t// Silent fail - icon will be fetched from network next time\n\t}\n}\n\nasync function performFetch(\n\ticonName: string,\n\tprefix: string,\n\tname: string,\n\tabortController?: AbortController\n): Promise<string> {\n\ttry {\n\t\tconst url = `${API_BASE_PATH}/${encodeURIComponent(prefix)}/${encodeURIComponent(name)}`;\n\t\tconst response = await fetch(url, {\n\t\t\theaders: { Accept: 'application/json' },\n\t\t\tsignal: abortController?.signal,\n\t\t});\n\n\t\tif (!response.ok) {\n\t\t\tthrow new IconError(\n\t\t\t\tresponse.status === 404 ? IconErrorType.NAME_NOT_FOUND : IconErrorType.FETCH_FAILED,\n\t\t\t\tresponse.status === 404\n\t\t\t\t\t? `We couldn't find an icon with the provided name.`\n\t\t\t\t\t: `Failed to fetch icon: ${response.status} ${response.statusText}`\n\t\t\t);\n\t\t}\n\n\t\tconst data: IconApiResponse = await response.json();\n\n\t\tif (!data.svg) {\n\t\t\tthrow new IconError(\n\t\t\t\tIconErrorType.INVALID_RESPONSE,\n\t\t\t\t`Invalid API response: missing SVG data for \"${iconName}\"`\n\t\t\t);\n\t\t}\n\n\t\treturn data.svg;\n\t} catch (error) {\n\t\tif (error instanceof IconError || (error instanceof DOMException && error.name === 'AbortError')) {\n\t\t\tthrow error;\n\t\t}\n\t\tthrow new IconError(\n\t\t\tIconErrorType.FETCH_FAILED,\n\t\t\t`Network error while fetching icon \"${iconName}\"`,\n\t\t\terror instanceof Error ? error : undefined\n\t\t);\n\t}\n}\n\nconst IconRegistry = {\n\tfetchIcon,\n};\n\ndeclare global {\n\tinterface Window {\n\t\tIconRegistry?: typeof IconRegistry;\n\t}\n}\n\nif (typeof window !== 'undefined') {\n\twindow.IconRegistry = IconRegistry;\n}\n\nexport default IconRegistry;\n","import { IconError, IconErrorType, fetchIcon as fetchIconFromRegistry } from './IconRegistry';\n\ninterface ParsedIconName {\n\tprefix: string;\n\tname: string;\n}\n\ninterface IconConfig {\n\tname: string;\n\twidth: string;\n\theight: string;\n\tcolor?: string;\n}\n\nexport type IconStatus = 'rendered' | 'loading' | 'failed';\n\nexport interface IconRendererState {\n\trenderStatus: IconStatus;\n\trenderAbortController: AbortController | null;\n\tlastError: IconError | null;\n\tactiveIconName: string | null;\n\tmutationObserver: MutationObserver | null;\n\toriginalWidth: string | null;\n\toriginalHeight: string | null;\n\tcachedSvgElement: SVGSVGElement | null;\n}\n\nexport class OmniIconRenderer {\n\tprivate static readonly ICON_NAME_SEPARATOR = ':';\n\tprivate static readonly FALLBACK_ICON = 'tabler:error-404';\n\tprivate static readonly FALLBACK_PRIORITY = 10;\n\tprivate static readonly RESERVED_ATTRS = new Set(['name', 'id', 'role', 'aria-expanded', 'tabindex']);\n\tprivate static readonly SVG_ATTRS = new Set(['xmlns', 'viewBox', 'aria-hidden', 'focusable']);\n\tprivate static readonly CLEANUP_ATTRS = ['data-oiwc-state', 'data-oiwc-error-type', 'data-oiwc-original-icon', 'data-oiwc-expanded', 'role', 'aria-expanded', 'tabindex'];\n\n\tprivate states = new WeakMap<Element, IconRendererState>();\n\t\n\t// Lazy load ErrorObserver only when first error occurs\n\tprivate static errorObserverPromise: Promise<void> | null = null;\n\tprivate static errorObserverLoaded = false;\n\n\tprivate getState(element: Element): IconRendererState {\n\t\tlet state = this.states.get(element);\n\t\tif (!state) {\n\t\t\tstate = {\n\t\t\t\trenderStatus: 'loading',\n\t\t\t\trenderAbortController: null,\n\t\t\t\tlastError: null,\n\t\t\t\tactiveIconName: null,\n\t\t\t\tmutationObserver: null,\n\t\t\t\toriginalWidth: null,\n\t\t\t\toriginalHeight: null,\n\t\t\t\tcachedSvgElement: null,\n\t\t\t};\n\t\t\tthis.states.set(element, state);\n\t\t}\n\t\treturn state;\n\t}\n\n\tattachRenderer(element: Element): void {\n\t\tconst state = this.getState(element);\n\n\t\t// Skip rendering if data-prerendered attribute is present\n\t\tif (element.hasAttribute('data-prerendered')) {\n\t\t\tstate.renderStatus = 'rendered';\n\t\t\t// Still observe for attribute changes that might require re-rendering\n\t\t\tthis.observeElement(element);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.renderIcon(element);\n\t\tthis.observeElement(element);\n\t}\n\n\tdetachRenderer(element: Element): void {\n\t\tconst state = this.getState(element);\n\t\t\n\t\tstate.renderAbortController?.abort();\n\t\tstate.renderAbortController = null;\n\t\tstate.activeIconName = null;\n\t\tstate.originalWidth = null;\n\t\tstate.originalHeight = null;\n\t\tstate.cachedSvgElement = null;\n\n\t\tif (state.mutationObserver) {\n\t\t\tstate.mutationObserver.disconnect();\n\t\t\tstate.mutationObserver = null;\n\t\t}\n\n\t\tthis.states.delete(element);\n\t}\n\n\trestartAnimation(element: Element): void {\n\t\tconst state = this.getState(element);\n\t\tconst svgElement = state.cachedSvgElement || element.querySelector('svg');\n\t\tif (svgElement && state.renderStatus === 'rendered') {\n\t\t\ttry {\n\t\t\t\t(svgElement as SVGSVGElement).setCurrentTime?.(0);\n\t\t\t} catch {\n\t\t\t\tthis.renderIcon(element);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate observeElement(element: Element): void {\n\t\tconst state = this.getState(element);\n\n\t\t// Don't create observer if already exists\n\t\tif (state.mutationObserver) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Watch for all attribute changes\n\t\tstate.mutationObserver = new MutationObserver((mutations) => {\n\t\t\tmutations.forEach((mutation) => {\n\t\t\t\tif (mutation.type === 'attributes') {\n\t\t\t\t\tconst attributeName = mutation.attributeName;\n\n\t\t\t\t\t// If data-prerendered is added, stop observing and preserve content\n\t\t\t\t\tif (attributeName === 'data-prerendered' && element.hasAttribute('data-prerendered')) {\n\t\t\t\t\t\tstate.renderAbortController?.abort();\n\t\t\t\t\t\tstate.renderStatus = 'rendered';\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If data-prerendered is removed, start rendering\n\t\t\t\t\tif (attributeName === 'data-prerendered' && !element.hasAttribute('data-prerendered')) {\n\t\t\t\t\t\tthis.renderIcon(element);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Skip all updates if data-prerendered is present\n\t\t\t\t\tif (element.hasAttribute('data-prerendered')) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If name changed, re-fetch the icon\n\t\t\t\t\tif (attributeName === 'name') {\n\t\t\t\t\t\tthis.renderIcon(element);\n\t\t\t\t\t}\n\n\t\t\t\t\t// For other attributes, just update the SVG if already rendered\n\t\t\t\t\telse if (state.renderStatus === 'rendered') {\n\t\t\t\t\t\tthis.updateSvgAttributes(element);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\tstate.mutationObserver.observe(element, {\n\t\t\tattributes: true,\n\t\t\tattributeOldValue: false, // We don't use oldValue anywhere - saves memory\n\t\t});\n\t}\n\n\tprivate getConfig(element: Element): IconConfig {\n\t\tconst state = this.getState(element);\n\t\tconst attrWidth = element.getAttribute('width');\n\t\tconst attrHeight = element.getAttribute('height');\n\n\t\t// Determine dimensions: attribute > original\n\t\tlet width = attrWidth || state.originalWidth || '';\n\t\tlet height = attrHeight || state.originalHeight || '';\n\n\t\t// If one dimension is specified but not the other, match them\n\t\tif (attrWidth && !attrHeight) {\n\t\t\theight = attrWidth;\n\t\t} else if (attrHeight && !attrWidth) {\n\t\t\twidth = attrHeight;\n\t\t}\n\n\t\treturn {\n\t\t\tname: element.getAttribute('name') || '',\n\t\t\twidth,\n\t\t\theight,\n\t\t\tcolor: element.getAttribute('color') || undefined,\n\t\t};\n\t}\n\n\tprivate parseIconName(iconName: string): ParsedIconName {\n\t\tif (!iconName) {\n\t\t\tthrow new IconError(IconErrorType.NO_NAME, 'No icon name specified');\n\t\t}\n\n\t\tconst separatorIndex = iconName.indexOf(OmniIconRenderer.ICON_NAME_SEPARATOR);\n\n\t\tif (separatorIndex === -1 || separatorIndex === 0 || separatorIndex === iconName.length - 1) {\n\t\t\tthrow new IconError(\n\t\t\t\tIconErrorType.INVALID_FORMAT,\n\t\t\t\t`Invalid icon format: \"${iconName}\". Expected format: \"prefix:name\"`\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\tprefix: iconName.substring(0, separatorIndex).trim(),\n\t\t\tname: iconName.substring(separatorIndex + 1).trim(),\n\t\t};\n\t}\n\n\tprivate async renderIcon(element: Element): Promise<void> {\n\t\tconst state = this.getState(element);\n\n\t\tif (element.hasAttribute('data-prerendered')) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst config = this.getConfig(element);\n\t\tconst targetIconName = config.name;\n\t\tconst iconChanged = targetIconName !== state.activeIconName;\n\n\t\t// Abort previous render if icon changed\n\t\tif (iconChanged && state.renderAbortController) {\n\t\t\tstate.renderAbortController.abort();\n\t\t\tstate.renderAbortController = null;\n\t\t}\n\n\t\t// Update active icon name\n\t\tif (iconChanged) {\n\t\t\tstate.activeIconName = targetIconName || null;\n\t\t}\n\n\t\t// Create new controller if needed\n\t\tif (!state.renderAbortController) {\n\t\t\tstate.renderAbortController = new AbortController();\n\t\t}\n\n\t\tconst renderController = state.renderAbortController;\n\n\t\ttry {\n\t\t\tstate.renderStatus = 'loading';\n\t\t\tthis.renderLoading(element, config);\n\n\t\t\tconst svg = await this.fetchIcon(config.name, renderController.signal);\n\t\t\tif (renderController.signal.aborted) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.renderSvg(element, svg, config);\n\t\t} catch (error) {\n\t\t\tif (renderController.signal.aborted) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstate.renderStatus = 'failed';\n\t\t\tconst iconError = error instanceof IconError\n\t\t\t\t? error\n\t\t\t\t: new IconError(\n\t\t\t\t\tIconErrorType.FETCH_FAILED,\n\t\t\t\t\terror instanceof Error ? error.message : 'Unknown error occurred',\n\t\t\t\t\terror instanceof Error ? error : undefined\n\t\t\t\t);\n\t\t\tawait this.renderError(element, iconError, renderController.signal);\n\t\t} finally {\n\t\t\tif (state.renderAbortController === renderController) {\n\t\t\t\tstate.renderAbortController = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate renderLoading(element: Element, config: IconConfig): void {\n\t\telement.setAttribute('data-oiwc-state', 'loading');\n\t\t['data-oiwc-error-type', 'data-oiwc-original-icon', 'data-oiwc-expanded'].forEach(attr => element.removeAttribute(attr));\n\t\tif (config.width) (element as HTMLElement).style.width = `${config.width}px`;\n\t\tif (config.height) (element as HTMLElement).style.height = `${config.height}px`;\n\t\telement.innerHTML = '';\n\t}\n\n\tprivate renderSvg(element: Element, svg: string, config: IconConfig): void {\n\t\tconst state = this.getState(element);\n\t\tconst wasError = state.lastError !== null;\n\n\t\telement.innerHTML = svg;\n\t\tstate.cachedSvgElement = element.querySelector('svg');\n\n\t\tif (state.cachedSvgElement) {\n\t\t\t// Store original dimensions from SVG before modifying\n\t\t\tif (!state.originalWidth) {\n\t\t\t\tstate.originalWidth = state.cachedSvgElement.getAttribute('width');\n\t\t\t}\n\t\t\tif (!state.originalHeight) {\n\t\t\t\tstate.originalHeight = state.cachedSvgElement.getAttribute('height');\n\t\t\t}\n\n\t\t\tstate.cachedSvgElement.setAttribute('aria-hidden', 'true');\n\t\t\tstate.cachedSvgElement.setAttribute('focusable', 'false');\n\t\t\tthis.passAttributesToSvg(element, state.cachedSvgElement);\n\t\t}\n\n\t\tstate.renderStatus = 'rendered';\n\t\t// Batch remove cleanup attributes\n\t\tOmniIconRenderer.CLEANUP_ATTRS.forEach(attr => element.removeAttribute(attr));\n\t\t(element as HTMLElement).style.width = '';\n\t\t(element as HTMLElement).style.height = '';\n\t\t(element as HTMLElement).style.cursor = '';\n\n\t\telement.dispatchEvent(\n\t\t\tnew CustomEvent('omni-icon:loaded', {\n\t\t\t\tdetail: {\n\t\t\t\t\ticonName: config.name,\n\t\t\t\t\twasError,\n\t\t\t\t\telement,\n\t\t\t\t},\n\t\t\t\tbubbles: true,\n\t\t\t\tcomposed: true,\n\t\t\t})\n\t\t);\n\n\t\tstate.lastError = null;\n\t}\n\n\tprivate async renderError(element: Element, error: IconError, signal?: AbortSignal): Promise<void> {\n\t\tconst state = this.getState(element);\n\t\tstate.lastError = error;\n\t\tconst config = this.getConfig(element);\n\n\t\telement.setAttribute('data-oiwc-state', 'error');\n\t\telement.setAttribute('data-oiwc-error-type', error.type);\n\t\telement.setAttribute('data-oiwc-original-icon', config.name);\n\t\t// Only set dimensions if they exist\n\t\tif (config.width) (element as HTMLElement).style.width = `${config.width}px`;\n\t\tif (config.height) (element as HTMLElement).style.height = `${config.height}px`;\n\n\t\ttry {\n\t\t\tconst fallbackSvg = await this.fetchIcon(\n\t\t\t\tOmniIconRenderer.FALLBACK_ICON,\n\t\t\t\tsignal,\n\t\t\t\tOmniIconRenderer.FALLBACK_PRIORITY\n\t\t\t);\n\t\t\tif (signal?.aborted) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\telement.innerHTML = fallbackSvg;\n\t\t\tconst svgElement = element.querySelector('svg');\n\t\t\tif (svgElement) {\n\t\t\t\tsvgElement.setAttribute('aria-hidden', 'true');\n\t\t\t\tsvgElement.setAttribute('focusable', 'false');\n\t\t\t\tthis.passAttributesToSvg(element, svgElement);\n\t\t\t}\n\t\t} catch {\n\t\t\tif (signal?.aborted) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\telement.innerHTML = '';\n\t\t}\n\n\t\t// Lazy load ErrorObserver on first error\n\t\tawait this.ensureErrorObserver();\n\n\t\telement.dispatchEvent(\n\t\t\tnew CustomEvent('omni-icon:error', {\n\t\t\t\tdetail: {\n\t\t\t\t\ttype: error.type,\n\t\t\t\t\tmessage: error.message,\n\t\t\t\t\ticonName: config.name,\n\t\t\t\t\telement,\n\t\t\t\t},\n\t\t\t\tbubbles: true,\n\t\t\t\tcomposed: true,\n\t\t\t})\n\t\t);\n\t}\n\n\tprivate async ensureErrorObserver(): Promise<void> {\n\t\tif (!OmniIconRenderer.errorObserverLoaded && !OmniIconRenderer.errorObserverPromise) {\n\t\t\tOmniIconRenderer.errorObserverPromise = import('./ErrorObserver').then(({ ErrorObserver }) => {\n\t\t\t\tnew ErrorObserver();\n\t\t\t\tOmniIconRenderer.errorObserverLoaded = true;\n\t\t\t});\n\t\t}\n\t\tawait OmniIconRenderer.errorObserverPromise;\n\t}\n\n\tprivate shouldSkipAttribute(attrName: string): boolean {\n\t\treturn attrName.startsWith('data-oiwc-') || OmniIconRenderer.RESERVED_ATTRS.has(attrName);\n\t}\n\n\tprivate passAttributesToSvg(element: Element, svgElement: SVGSVGElement): void {\n\t\tArray.from(element.attributes).forEach((attr) => {\n\t\t\tif (!this.shouldSkipAttribute(attr.name)) {\n\t\t\t\tsvgElement.setAttribute(attr.name, attr.value);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate updateSvgAttributes(element: Element): void {\n\t\tconst state = this.getState(element);\n\t\t// Use cached SVG element to avoid DOM query\n\t\tconst svgElement = state.cachedSvgElement || element.querySelector('svg');\n\t\tif (!svgElement) {\n\t\t\treturn;\n\t\t}\n\t\tstate.cachedSvgElement = svgElement;\n\n\t\t// Get current attributes on the omni-icon element\n\t\tconst hostAttrs = new Map<string, string>();\n\t\tArray.from(element.attributes).forEach((attr) => {\n\t\t\tif (!this.shouldSkipAttribute(attr.name)) {\n\t\t\t\thostAttrs.set(attr.name, attr.value);\n\t\t\t}\n\t\t});\n\n\t\t// Remove attributes from SVG that are no longer on the host\n\t\tArray.from(svgElement.attributes).forEach((attr) => {\n\t\t\tconst attrName = attr.name;\n\t\t\t// Skip SVG-specific attributes\n\t\t\tif (!OmniIconRenderer.SVG_ATTRS.has(attrName) &&\n\t\t\t\t!OmniIconRenderer.RESERVED_ATTRS.has(attrName) &&\n\t\t\t\t!hostAttrs.has(attrName)) {\n\t\t\t\tsvgElement.removeAttribute(attrName);\n\t\t\t}\n\t\t});\n\n\t\t// Add/update attributes from host to SVG\n\t\thostAttrs.forEach((value, name) => {\n\t\t\tsvgElement.setAttribute(name, value);\n\t\t});\n\t}\n\n\tprivate async fetchIcon(iconName: string, signal?: AbortSignal, priority = 0): Promise<string> {\n\t\tconst { prefix, name } = this.parseIconName(iconName);\n\t\treturn fetchIconFromRegistry(iconName, prefix, name, { signal, priority });\n\t}\n}\n"],"file":"OmniIconRenderer-CPDO0Yqc.js"}