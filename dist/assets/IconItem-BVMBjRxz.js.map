{"version":3,"file":"IconItem-BVMBjRxz.js","names":[],"sources":["../../resources/integration/gutenberg/blocks/icon-block/components/hooks.js","../../resources/integration/gutenberg/blocks/icon-block/components/IconItem.jsx"],"sourcesContent":["import { useState, useEffect, useRef, useMemo, useCallback } from '@wordpress/element';\nimport { __ } from '@wordpress/i18n';\n\n/**\n * Custom hook for debouncing a value\n * @param {*} value - The value to debounce\n * @param {number} delay - Delay in milliseconds\n * @returns {*} Debounced value\n */\nexport const useDebounce = (value, delay = 300) => {\n\tconst [debouncedValue, setDebouncedValue] = useState(value);\n\n\tuseEffect(() => {\n\t\tconst handler = setTimeout(() => {\n\t\t\tsetDebouncedValue(value);\n\t\t}, delay);\n\n\t\treturn () => {\n\t\t\tclearTimeout(handler);\n\t\t};\n\t}, [value, delay]);\n\n\treturn debouncedValue;\n};\n\n/**\n * Custom hook for fetching icon collections\n * @param {boolean} isOpen - Whether the modal is open\n * @returns {Object} { collections, isLoading, error, refreshCollections }\n */\nexport const useIconCollections = (isOpen) => {\n\tconst [collections, setCollections] = useState({});\n\tconst [isLoading, setIsLoading] = useState(false);\n\tconst [isRefreshing, setIsRefreshing] = useState(false);\n\tconst [error, setError] = useState(null);\n\tconst [refreshTrigger, setRefreshTrigger] = useState(0);\n\tconst abortControllerRef = useRef(null);\n\n\tconst refreshCollections = useCallback(() => {\n\t\tsetRefreshTrigger(prev => prev + 1);\n\t}, []);\n\n\tuseEffect(() => {\n\t\tif (!isOpen) return;\n\n\t\tconst fetchCollections = async () => {\n\t\t\t// Cancel previous request if exists\n\t\t\tif (abortControllerRef.current) {\n\t\t\t\tabortControllerRef.current.abort();\n\t\t\t}\n\n\t\t\tconst abortController = new AbortController();\n\t\t\tabortControllerRef.current = abortController;\n\n\t\t\ttry {\n\t\t\t\t// Only show main loading on initial load, not on refresh\n\t\t\t\tif (refreshTrigger === 0) {\n\t\t\t\t\tsetIsLoading(true);\n\t\t\t\t} else {\n\t\t\t\t\tsetIsRefreshing(true);\n\t\t\t\t}\n\t\t\t\tsetError(null);\n\t\t\t\t\n\t\t\t\t// Add cache-busting parameter when manually refreshing\n\t\t\t\tconst cacheBuster = refreshTrigger > 0 ? `?_=${Date.now()}` : '';\n\t\t\t\tconst response = await fetch(`/wp-json/omni-icon/v1/icon/collections${cacheBuster}`, {\n\t\t\t\t\theaders: { Accept: 'application/json' },\n\t\t\t\t\tsignal: abortController.signal,\n\t\t\t\t});\n\n\t\t\t\tif (!response.ok) {\n\t\t\t\t\tthrow new Error(`HTTP error! status: ${response.status}`);\n\t\t\t\t}\n\n\t\t\t\tconst data = await response.json();\n\t\t\t\tsetCollections(data.collections || {});\n\t\t\t} catch (err) {\n\t\t\t\t// Ignore abort errors\n\t\t\t\tif (err.name === 'AbortError') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsetError(__('Failed to load icon collections', 'omni-icon'));\n\t\t\t\tconsole.error('Error fetching collections:', err);\n\t\t\t} finally {\n\t\t\t\tif (abortControllerRef.current === abortController) {\n\t\t\t\t\tabortControllerRef.current = null;\n\t\t\t\t\tsetIsLoading(false);\n\t\t\t\t\tsetIsRefreshing(false);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tfetchCollections();\n\n\t\t// Cleanup: abort any ongoing requests when modal closes\n\t\treturn () => {\n\t\t\tif (abortControllerRef.current) {\n\t\t\t\tabortControllerRef.current.abort();\n\t\t\t\tabortControllerRef.current = null;\n\t\t\t}\n\t\t};\n\t}, [isOpen, refreshTrigger]);\n\n\treturn { collections, isLoading, isRefreshing, error, refreshCollections };\n};\n\n/**\n * Custom hook for searching icons\n * @param {string} query - Search query\n * @param {boolean} isOpen - Whether the modal is open\n * @returns {Object} { icons, isLoading, error }\n */\nexport const useIconSearch = (query, isOpen) => {\n\tconst [icons, setIcons] = useState([]);\n\tconst [isLoading, setIsLoading] = useState(false);\n\tconst [error, setError] = useState(null);\n\tconst abortControllerRef = useRef(null);\n\n\tuseEffect(() => {\n\t\tif (!isOpen || !query.trim()) {\n\t\t\tsetIcons([]);\n\t\t\treturn;\n\t\t}\n\n\t\tconst searchIcons = async () => {\n\t\t\t// Cancel previous search request if exists\n\t\t\tif (abortControllerRef.current) {\n\t\t\t\tabortControllerRef.current.abort();\n\t\t\t}\n\n\t\t\tconst abortController = new AbortController();\n\t\t\tabortControllerRef.current = abortController;\n\n\t\t\ttry {\n\t\t\t\tsetIsLoading(true);\n\t\t\t\tsetError(null);\n\n\t\t\t\tconst response = await fetch(\n\t\t\t\t\t`/wp-json/omni-icon/v1/icon/search?query=${encodeURIComponent(query)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: { Accept: 'application/json' },\n\t\t\t\t\t\tsignal: abortController.signal,\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tif (!response.ok) {\n\t\t\t\t\tconst errorData = await response.json();\n\t\t\t\t\tconst errorMessage = errorData.message || `HTTP error! status: ${response.status}`;\n\t\t\t\t\tthrow new Error(errorMessage);\n\t\t\t\t}\n\n\t\t\t\tconst data = await response.json();\n\n\t\t\t\t// Format ALL results to include full icon name\n\t\t\t\tconst formattedResults = (data.results || []).map(icon => ({\n\t\t\t\t\tname: `${icon.prefix}:${icon.name}`,\n\t\t\t\t\tprefix: icon.prefix,\n\t\t\t\t\ticonName: icon.name,\n\t\t\t\t}));\n\n\t\t\t\tsetIcons(formattedResults);\n\t\t\t} catch (err) {\n\t\t\t\t// Ignore abort errors\n\t\t\t\tif (err.name === 'AbortError') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst errorMessage = err.message || 'Unknown error';\n\t\t\t\tsetError(__('Failed to search icons', 'omni-icon') + ': ' + errorMessage);\n\t\t\t\tconsole.error('Error searching icons:', err);\n\t\t\t} finally {\n\t\t\t\tif (abortControllerRef.current === abortController) {\n\t\t\t\t\tabortControllerRef.current = null;\n\t\t\t\t\tsetIsLoading(false);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tsearchIcons();\n\n\t\t// Cleanup\n\t\treturn () => {\n\t\t\tif (abortControllerRef.current) {\n\t\t\t\tabortControllerRef.current.abort();\n\t\t\t\tabortControllerRef.current = null;\n\t\t\t}\n\t\t};\n\t}, [query, isOpen]);\n\n\treturn { icons, isLoading, error };\n};\n\n/**\n * Custom hook for generating default icons from collections\n * @param {Object} collections - Icon collections\n * @param {string} currentIcon - Currently selected icon\n * @returns {Array} Default icons array\n */\nexport const useDefaultIcons = (collections, currentIcon) => {\n\treturn useMemo(() => {\n\t\tconst defaultIcons = [];\n\n\t\t// Add current icon first if it exists\n\t\tif (currentIcon) {\n\t\t\tconst [prefix, iconName] = currentIcon.split(':');\n\t\t\tif (prefix && iconName) {\n\t\t\t\tdefaultIcons.push({\n\t\t\t\t\tname: currentIcon,\n\t\t\t\t\tprefix,\n\t\t\t\t\ticonName,\n\t\t\t\t\tisCurrent: true,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Add samples from ALL collections\n\t\tObject.entries(collections).forEach(([prefix, collection]) => {\n\t\t\tif (collection.samples && Array.isArray(collection.samples)) {\n\t\t\t\tcollection.samples.forEach(iconName => {\n\t\t\t\t\tconst fullName = `${prefix}:${iconName}`;\n\t\t\t\t\t// Don't duplicate the current icon\n\t\t\t\t\tif (fullName !== currentIcon) {\n\t\t\t\t\t\tdefaultIcons.push({\n\t\t\t\t\t\t\tname: fullName,\n\t\t\t\t\t\t\tprefix,\n\t\t\t\t\t\t\ticonName,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn defaultIcons;\n\t}, [collections, currentIcon]);\n};\n\n/**\n * Custom hook for filtering and paginating icons\n * @param {Array} allIcons - All available icons\n * @param {string} selectedCollection - Selected collection filter\n * @param {number} iconsPerPage - Number of icons per page\n * @returns {Object} { filteredIcons, paginatedIcons, totalPages, currentPage, setCurrentPage, collectionCounts }\n */\nexport const useIconFiltering = (allIcons, selectedCollection, iconsPerPage = 64) => {\n\tconst [currentPage, setCurrentPage] = useState(1);\n\n\t// Memoize filtered icons by collection\n\tconst filteredIcons = useMemo(() => {\n\t\tif (selectedCollection === 'all') {\n\t\t\treturn allIcons;\n\t\t}\n\t\treturn allIcons.filter(icon => icon.prefix === selectedCollection);\n\t}, [allIcons, selectedCollection]);\n\n\t// Calculate total pages\n\tconst totalPages = useMemo(() => {\n\t\treturn Math.ceil(filteredIcons.length / iconsPerPage);\n\t}, [filteredIcons.length, iconsPerPage]);\n\n\t// Reset to page 1 when collection changes or icons change\n\tuseEffect(() => {\n\t\tsetCurrentPage(1);\n\t}, [selectedCollection, allIcons]);\n\n\t// Memoize paginated icons\n\tconst paginatedIcons = useMemo(() => {\n\t\tconst startIndex = (currentPage - 1) * iconsPerPage;\n\t\tconst endIndex = startIndex + iconsPerPage;\n\t\treturn filteredIcons.slice(startIndex, endIndex);\n\t}, [filteredIcons, currentPage, iconsPerPage]);\n\n\t// Memoize collection counts\n\tconst collectionCounts = useMemo(() => {\n\t\tconst counts = {};\n\t\tallIcons.forEach(icon => {\n\t\t\tcounts[icon.prefix] = (counts[icon.prefix] || 0) + 1;\n\t\t});\n\t\treturn counts;\n\t}, [allIcons]);\n\n\treturn {\n\t\tfilteredIcons,\n\t\tpaginatedIcons,\n\t\ttotalPages,\n\t\tcurrentPage,\n\t\tsetCurrentPage,\n\t\tcollectionCounts,\n\t};\n};\n\n/**\n * Custom hook for keyboard navigation in icon grid\n * @param {Array} icons - Array of icons to navigate\n * @param {Function} onSelectIcon - Callback when icon is selected\n * @param {Function} onClose - Callback to close modal\n * @param {boolean} isOpen - Whether the modal is open\n * @returns {Object} { selectedIndex, setSelectedIndex, handleKeyDown }\n */\nexport const useKeyboardNavigation = (icons, onSelectIcon, onClose, isOpen) => {\n\tconst [selectedIndex, setSelectedIndex] = useState(-1);\n\tconst gridRef = useRef(null);\n\n\t// Reset selected index when icons change or modal opens\n\tuseEffect(() => {\n\t\tif (isOpen) {\n\t\t\tsetSelectedIndex(-1);\n\t\t}\n\t}, [icons, isOpen]);\n\n\t// Calculate actual number of columns in the grid\n\tconst getColumnCount = useCallback(() => {\n\t\tif (!gridRef.current) return 1;\n\t\t\n\t\t// Get the first two items in the grid\n\t\tconst items = gridRef.current.querySelectorAll('.oiib-icon-item');\n\t\tif (items.length < 2) return 1;\n\t\t\n\t\t// Calculate column count by checking how many items fit in one row\n\t\tconst firstItemTop = items[0].getBoundingClientRect().top;\n\t\tlet cols = 1;\n\t\t\n\t\tfor (let i = 1; i < items.length; i++) {\n\t\t\tconst itemTop = items[i].getBoundingClientRect().top;\n\t\t\t// If item is on the same row as the first item\n\t\t\tif (Math.abs(itemTop - firstItemTop) < 5) {\n\t\t\t\tcols++;\n\t\t\t} else {\n\t\t\t\t// We've reached the second row, stop counting\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn cols;\n\t}, []);\n\n\tconst handleKeyDown = useCallback((event) => {\n\t\tif (!icons.length) return;\n\t\t\n\t\tswitch (event.key) {\n\t\t\tcase 'ArrowRight':\n\t\t\t\tevent.preventDefault();\n\t\t\t\tsetSelectedIndex(prev => {\n\t\t\t\t\t// If nothing selected, start at index 0\n\t\t\t\t\tif (prev === -1) return 0;\n\t\t\t\t\tconst next = prev + 1;\n\t\t\t\t\treturn next >= icons.length ? prev : next;\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase 'ArrowLeft':\n\t\t\t\tevent.preventDefault();\n\t\t\t\tsetSelectedIndex(prev => {\n\t\t\t\t\t// If nothing selected, start at index 0\n\t\t\t\t\tif (prev === -1) return 0;\n\t\t\t\t\tconst next = prev - 1;\n\t\t\t\t\treturn next < 0 ? 0 : next;\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase 'ArrowDown':\n\t\t\t\tevent.preventDefault();\n\t\t\t\tsetSelectedIndex(prev => {\n\t\t\t\t\t// If nothing selected, start at index 0\n\t\t\t\t\tif (prev === -1) return 0;\n\t\t\t\t\tconst cols = getColumnCount();\n\t\t\t\t\tconst next = prev + cols;\n\t\t\t\t\treturn next >= icons.length ? prev : next;\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase 'ArrowUp':\n\t\t\t\tevent.preventDefault();\n\t\t\t\tsetSelectedIndex(prev => {\n\t\t\t\t\t// If nothing selected, start at index 0\n\t\t\t\t\tif (prev === -1) return 0;\n\t\t\t\t\tconst cols = getColumnCount();\n\t\t\t\t\tconst next = prev - cols;\n\t\t\t\t\treturn next < 0 ? prev : next;\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase 'Enter':\n\t\t\tcase ' ':\n\t\t\t\tevent.preventDefault();\n\t\t\t\tif (selectedIndex >= 0 && selectedIndex < icons.length) {\n\t\t\t\t\tonSelectIcon(icons[selectedIndex].name);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'Escape':\n\t\t\t\tevent.preventDefault();\n\t\t\t\tonClose();\n\t\t\t\tbreak;\n\n\t\t\tcase 'Home':\n\t\t\t\tevent.preventDefault();\n\t\t\t\tsetSelectedIndex(0);\n\t\t\t\tbreak;\n\n\t\t\tcase 'End':\n\t\t\t\tevent.preventDefault();\n\t\t\t\tsetSelectedIndex(icons.length - 1);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}, [icons, selectedIndex, onSelectIcon, onClose, getColumnCount]);\n\n\t// Scroll selected item into view\n\tuseEffect(() => {\n\t\tif (selectedIndex >= 0 && gridRef.current) {\n\t\t\tconst selectedElement = gridRef.current.querySelector(`[data-index=\"${selectedIndex}\"]`);\n\t\t\tif (selectedElement) {\n\t\t\t\tselectedElement.scrollIntoView({\n\t\t\t\t\tbehavior: 'smooth',\n\t\t\t\t\tblock: 'nearest',\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}, [selectedIndex]);\n\n\treturn { selectedIndex, setSelectedIndex, handleKeyDown, gridRef };\n};\n","import { memo, useState, useCallback } from '@wordpress/element';\nimport IconCheck from '~icons/tabler/check';\n\n/**\n * IconItem Component\n * Displays a single icon in the icon picker grid\n * Memoized to prevent unnecessary re-renders\n */\nconst IconItem = memo(({ \n\ticon, \n\tisSelected, \n\tisFocused,\n\tonSelect, \n\tindex \n}) => {\n\tconst [isOverflowing, setIsOverflowing] = useState(false);\n\tconst [scrollDistance, setScrollDistance] = useState('0px');\n\tconst [scrollDuration, setScrollDuration] = useState('3s');\n\n\tconst handleMouseEnter = useCallback((e) => {\n\t\tconst nameEl = e.currentTarget.querySelector('.oiib-icon-name');\n\t\tif (nameEl && nameEl.scrollWidth > nameEl.clientWidth) {\n\t\t\t// Calculate distance to scroll\n\t\t\tconst distance = nameEl.scrollWidth - nameEl.clientWidth;\n\t\t\t// Calculate duration: 25 pixels per second for constant speed\n\t\t\tconst duration = (distance / 25);\n\t\t\t\n\t\t\tsetScrollDistance(`-${distance}px`);\n\t\t\tsetScrollDuration(`${duration}s`);\n\t\t\tsetIsOverflowing(true);\n\t\t}\n\t}, []);\n\n\tconst handleMouseLeave = useCallback(() => {\n\t\tsetIsOverflowing(false);\n\t}, []);\n\n\tconst handleClick = useCallback(() => {\n\t\tonSelect(icon.name);\n\t}, [icon.name, onSelect]);\n\n\tconst handleKeyDown = useCallback((e) => {\n\t\tif (e.key === 'Enter' || e.key === ' ') {\n\t\t\te.preventDefault();\n\t\t\tonSelect(icon.name);\n\t\t}\n\t}, [icon.name, onSelect]);\n\n\treturn (\n\t\t<button\n\t\t\tclassName={`oiib-icon-item ${isSelected ? 'is-selected' : ''} ${isFocused ? 'is-focused' : ''}`}\n\t\t\tonClick={handleClick}\n\t\t\tonKeyDown={handleKeyDown}\n\t\t\tonMouseEnter={handleMouseEnter}\n\t\t\tonMouseLeave={handleMouseLeave}\n\t\t\ttitle={icon.name}\n\t\t\tdata-index={index}\n\t\t\ttabIndex={isFocused ? 0 : -1}\n\t\t\taria-label={`Select icon ${icon.name}`}\n\t\t\taria-pressed={isSelected}\n\t\t>\n\t\t\t{isSelected && (\n\t\t\t\t<div className=\"oiib-icon-selected-badge\">\n\t\t\t\t\t<IconCheck />\n\t\t\t\t</div>\n\t\t\t)}\n\t\t\t<div className=\"oiib-icon-preview\">\n\t\t\t\t<omni-icon\n\t\t\t\t\tname={icon.name}\n\t\t\t\t\twidth=\"32\"\n\t\t\t\t\theight=\"32\"\n\t\t\t\t/>\n\t\t\t</div>\n\t\t\t<div className=\"oiib-icon-label\">\n\t\t\t\t<span \n\t\t\t\t\tclassName={`oiib-icon-name ${isOverflowing ? 'is-overflowing' : ''}`}\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\t'--scroll-distance': scrollDistance,\n\t\t\t\t\t\t'--scroll-duration': scrollDuration,\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t{icon.iconName}\n\t\t\t\t</span>\n\t\t\t\t<span className=\"oiib-icon-prefix\">{icon.prefix}</span>\n\t\t\t</div>\n\t\t</button>\n\t);\n});\n\nIconItem.displayName = 'IconItem';\n\nexport default IconItem;\n"],"mappings":"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"}